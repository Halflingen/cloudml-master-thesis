\mychapter{background}{Background: Cloud computing and Model-Driven Engineering}
\input{tables/tabproviders}
\input{figs/cloudlayers}

In this chapter the essential background topics for this thesis is introduced,
that is cloud computing and Model-Driven architecture.

\section{Cloud computing}

Cloud computing is gaining popularity and more companies are starting 
to explore the possibilities as well as the limitation to the cloud.
The definitins under are mainly based on definitions by 
the \emph{National Institute of Standards and Technology}~(NIST) which is one of 
the leaders in cloud computing standardization.
The main providers of cloud computing at writing moment 
are Google, Amazon with \emph{Amazon Web Service}~(AWS)~\cite{aws} and Microsoft \todo{source?}.
A non-exhaustive list of common providers are visualized in \citetable{providerservices}.

\subsection{Characteristics}

Many characteristics of cloud computing is based on the ability to scale, both upwards and inwards.
Some of the most essential characteristics of cloud computing~\cite{nist:mell11} are:

\paragraph{On-demand self-service.} 

Consumers can do provisioning without any human interaction.
On-demand means dynamic scalability and elasticity of resource allocation,
self-service means that users does not need to manually do these allocations themselves.
Consider an online election system, for most of the year it will most likely have very
low usage demands, but before and under election days it will have to serve
a much larger amount of requests. With on-demand self-service the online election system
could automatically be given more resources such as memory, computation power or even
increase the number for instances to handle peak loads.
The previous example has planned (or known) peak intervals, so even though automatic handling
is appealing it could be solved by good planning. 
But sometimes predicting load peaks can be difficult, such as when a product suddenly
gets more popular.

\paragraph{Broad network access.}

Capabilities available over standard network mechanisms.
Supporting familiar protocols such as HTTP/HTTPS and SSH.
This means that users can utilize tools and software they are most likely already possesses
or will have little difficulty gaining, such as web browsers.
Most cloud providers also provide web based consoles/interfaces that users can use
to create, delete and manage their resources.

\paragraph{Resource pooling.}

Physical and virtual resources are pooled so they can be 
dynamically assigned and reassigned according to consumer demand.
This means users do not need to be troubled with scalability as this is handled automatically.
This is a provider side characteristic which directly influence \emph{on-demand self-service}.
There is also a sense of location independence, which means users do not have specific geographical
information about where resources are hosted from, only on higher levels of abstraction (country, state).

\paragraph{Rapid elasticity.}

Automatic capability scaling.
Already allocated resources can expand to meet new demands.
Towards the characteristic of \emph{on-demand self-service} this means that allocation
can happen instantly, which means on unexpected peak loads the pressure will be
instantly handled by scaling upwards.
It is important to underline that such features can be cost heavy if not limited,
because costs reflect resource allocation.
\paragraph{Measured service.}

Monitoring and control of resource usages.
Can be used for statistics for users, for instance to do analytical research on product popularity
or determine user groups based on geographical data or browser usage.
The providers themselves use this information to handle \emph{on-demand services},
if they notice that an instance has a peak in load or has a noticeable increase 
in requests they can automatically allocate more resources or capabilities 
to leave pressure.
\emph{Measuring} can also help providers with billing, if they for instance
charge by resource load and not only amount of resources allocated.

\subsection{Service models}

\emph{Service models} are definitions of different layers in cloud computing.
The layers represent the amount of abstraction developers get from each \emph{service model}.
Higher layers have more abstraction, but can be more limited, while lower levels 
have less abstraction and are more customizable.
Limitations could be in many different forms, such as bound to a specific operating system,
programming language or framework.
There are three main architectural service models in cloud computing\cite{nist:mell11}
as seen as vertical integration levels in \citefig{cloudlayers},
namely \emph{Infrastructure-as-a-Service}~(IaaS), \emph{Platform-as-a-Service}~(PaaS)
and \emph{Software-as-a-Service}~(SaaS).
IaaS is on the lowest closest to physical hardware and SaaS on the highest
level as runnable applications.

  \paragraph{IaaS.}

This layer is similar to more standard solutions such as \emph{Virtual Private Servers}~(VPS),
and is therefore the \emph{service model} closest to standard hosting solutions.
Stanoevska-Slabeva~\cite{introduction:wozniak10} emphasizes that
\emph{''infrastructure had been available as a service for quite some time``} and this 
\emph{''has been referred to as utility computing, such as Sun Grid Compute Utility``}.
Which means IaaS can also be compared to grid computing, 
a well known term in the academic world.
The NIST Definition of Cloud Computing~\cite{nist:mell11} define IaaS as
\epigraph{The capability provided to the consumer is to provision 
  processing, storage, networks, and other fundamental computing resources where the 
  consumer is able to deploy and run arbitrary software, which can include operating 
  systems and applications.
}{\todo{NIST, 2011}}
This underline the liberty this \emph{service model} provide users, but this also means
that developers need to handle software and tools them selves, from operating system and
up to their application. In some cases this is wanted, for instance when deploying 
native libraries and tools that applications rely on such as tools to convert and edit
images or video files. But in other cases this is not necessary and choosing this \emph{service model}
can be manpower in-effective for companies as developers must focus on meta tasks.
NIST continue to state that 
\epigraph{The consumer does not manage or control the underlying cloud 
  infrastructure but has control over operating systems, storage, deployed applications, and 
  possibly limited control of select networking components (\eg, host firewalls).
}{\todo{NIST, 2011}}
This means users have control over which operating system they want, in some cases users
can only pick from a set of pre-configured operating systems.
It is common for providers to include both Linux and Windows in their selections.
Some providers such as Amazon let users upload their own disk images.
A similarity to VPS is that operating systems are not manually installed,
when selecting an operating system this is copied directly into the instance pre-installed
and will therefore be instantly ready for usage.
Examples of providers of IaaS are AWS \emph{Elastic Compute Cloud}~(EC2) and Rackspace CloudServers.

\paragraph{PaaS.}

Cloud computing is built to guide and assist developers through abstractions, and the next
layer in the \emph{service model} is designed to aid developers by detaching them
from configuration of operating system and frameworks.
NIST state that developers will can \emph{``applications created using programming languages, 
libraries, services, and tools supported by the provider''}~\cite{nist:mell11}.
This means that developers are limited to these capabilities the provider support,
such as programming languages (Java, C\#), environments (JVM, .NET, Node.js), 
storage systems (flat files, NoSQL databases, RDBMS).
For example the first versions of \emph{Google App Engine}~(GAE) did only support
an internal key-value based database called BigTable, this is still their main database.
This database is transparently interfaced using their API, but also support technologies such as JPA and JDO,
this means users are bound to Java and these frameworks, and even limitations to the frameworks
as they have specific handlers for RDBMS.

PaaS providers support deployments through online APIs, in many cases by providing 
specific tools such as command line interfaces or plugins to IDEs like Eclipse.
It is common for the API to have client built on technologies related to the technology supported by the PaaS,
for instance Heroku has a Ruby-based client and Nodejitsu has an executable Node.js-module as client.

Examples of PaaS providers are Google with \emph{Google App Engine}~(GAE) and
the company Heroku with their service with the same name.
Amazon also entered the PaaS market with their service named Elastic Beanstalk,
which is an abstraction over EC2 as IaaS underneath.
Multiple PaaS providers utilize EC2 as underlying infrastructure, examples of such
providers are Heroku Nodester and Nodejitsu, this is a tendency with increasing popularity.

\paragraph{SaaS.}

The highest layer of the \emph{service models} farthest away from physical hardware
and with highest level of abstraction.
NIST describe SaaS as
\epigraph{The capability provided to the consumer is to use the provider's 
  applications running on a cloud infrastructure.
}{\todo{NIST, 2011}}

The core purpose is to provide whole applications as services, in many cases end products.
Google products such as gmail, Google Apps and  Google Calendar are examples of 
SaaS applications.
What separates SaaS applications from other applications is the underlying cloud infrastructure,
by utilizing the five characteristics of cloud computing SaaS applications achieve 
cloud computing advantages.

It is not imposed that SaaS deployments are web applications, they can also consist of
different technologies such as RESTful APIs or SOAP services, but it most common to utilize the HTTP protocol.
In SaaS applications end users are most likely not the companies renting from providers, 
but instead the companies customers.
This means that the abstraction layer covers most of all aspects around an application,
the only exception could be customizations and settings that end users can do albeit 
this can be application specific. In some cases providers have services that affect
these users as well, such as \emph{Single Sign-on}.

\subsection{Deployment models}

\emph{Deployment models} define where and how applications are deployed in a cloud environment,
such as publicly with a global provider or private in local data centers.

There are four different \emph{deployment models} according to The 
NIST Definition of Cloud Computing~\cite{nist:mell11}:

\paragraph{Public cloud.}

In this \emph{deployment model} infrastructure is open to the public,
so companies can rent services from cloud providers.
The benefit of this model is that companies can save costs as 
they do not need to purchase physical hardware or manpower to build and maintain such hardware.

Cloud providers own the hardware and rent out IaaS and PaaS solutions to users.
Examples of such providers are Amazon with AWS and Google with GAE.

\paragraph{Private cloud.}

Similar to classical infrastructures where hardware and
operation is owned and controlled by organizations themselves.
This deployment model has arisen because of security issues regarding storage 
of data in public clouds. With \emph{private cloud} organization can provide 
data security in forms such as geographical location and existing domain specific firewalls,
and help complying requirements set by the government or other offices.
\paragraph{Community cloud.}

Similar as \emph{private clouds} but run as a
coalition between several organizations.
When several organizations share the same aspects of
a private cloud (such as security requirements, policies, and compliance considerations),
and therefore share infrastructure. 

\paragraph{Hybrid cloud.}

Combining private cloud or community cloud with public cloud.
One benefit is to distinguish data from logic for purposes such as security issues,
by storing sensitive information in a private cloud while computing with public cloud.

Beside these models defined by NIST there is another arising model known as 
\emph{virtual private cloud}, which is similar to \emph{public cloud} 
but with some security implications such as sandboxed network.

\section{Model-Driven Architecture approach}

By combining the world of cloud computing with the one of modeling 
it is possible to achieve benefits such as improved communication when designing 
a system and better understanding of the system itself.
This statement is emphasized by Booch \etal in one of his studies:
\epigraph{
  ``Modeling is a central
  part of all the activities that lead up to the deployment of good
  software. We build models to communicate the desired structure and
  behavior of our system. We build models to visualize and control the
  system's architecture. We build models to better understand the
  system we are building, often exposing opportunities for
  simplification and reuse. We build models to manage risk.''
}{\todo{Booch, 2005}}
When it comes to cloud computing these definitions are even more important
because of financial aspects since provisioned nodes instantly draw credit.
The definition of ``modeling'' can be assessed from the previous epigraph, but it is 
also important to choose correct models for the task.
Stanoevska-Slabeva emphasizes in one of her studies that grid computing
``\emph{is the starting point and basis for Cloud Computing.}''~\cite{introduction:wozniak10}.
As grid computing bear similarities towards cloud computing in terms of vitalization and utility computing
it is possible to use the same UML diagrams for IaaS as previously used in grid computing.
The importance of this re-usability of models is based on the origination of grid computing, \emph{eScience},
and the popularity of modeling in this research area.
The importance of choosing correct models is emphasized by Booch~\cite{unified:booch05}:
\epigraph{
  \begin{ii}\iitem The choice
  of what models to create has a profound influence on how a problem
  is attacked and how a solution is shaped. \iitem Every model may be
  expressed at different levels of precision. \iitem The best models
  are connected to reality. \iitem No single model is
  sufficient. Every nontrivial system is best approached through a
  small set of nearly independent models.\end{ii}
}{\todo{Booch, 2005}}
These definition precepts state that several models (precept \iii{4}) on different levels (precept \iii{2}) 
of precision should be used to model the same system.
From this it is concludable that several models can be used to describe one or several cloud computing perspectives.
Nor are there any restraints to only use UML diagrams or even models at all.
As an example AWS CloudFormation implements a lexical model of their \emph{cloud services},
while CA AppLogic has a visual and more UML component-based diagram of their capabilities.

\paragraph{Model-Driven Architexture.}
When working with \emph{Model-Driven Architecture}~(MDA) it is common to first create a
\emph{Computation Independent Model}~(CIM), then a \emph{Platform-Independent Model}~(PIM) and
lastly a \emph{Platform-Specific Model}~(PSM). There are other models and steps in between these,
but they render the essentials.
There are five different life cycles as explained by Singh~\cite{model-driven:singh09}:
\begin{enumerate}
  \item Create a CIM capturing requirements.
  \item Develop a PIM.
  \item Convert the PIM into PSM.
  \item Generate code form PSM.
  \item Deploy.
\end{enumerate}
