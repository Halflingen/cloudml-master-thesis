\mychapter{background}{Background: Cloud computing and Model-Driven Engineering}

In this chapter the essential background topics for this thesis are introduced.
The first topic is cloud computing, a way of providing computing power as a service
instead of being a product.
The second topic is about Model-Driven Engineering and Model-Driven Architecture
and these in some relation to cloud computing.

\section{Cloud computing}
\input{tables/tabproviders}

Cloud computing is gaining popularity and more companies are starting 
to explore the possibilities as well as the limitation to the cloud.
A good example of cloud adaptation in a large scale scenario is when
the White House moved their recovery.gov~\cite{recovery} operation to
a cloud infrastructure, this was estimated to save them \$750,000
at the current time, and even more on a long-term basis.
This section is based on the \myac{NIST} standard.

The definitions under are mainly based on definitions provided by 
the \myac{NIST} which is one of the leaders in cloud computing standardization.
The main providers of cloud computing in \date{April 2012}
are Google, Amazon with \myac{AWS}~\cite{aws} and Microsoft.
A non-exhaustive list of common providers is reproduced in \citetable{providerservices}.

\subsection{Characteristics}

Cloud computing is about providing computation as services\cite{nist:mell11}, 
such as virtual instances and file storage, rather than products. 
Cloud characteristics are what define
the difference between normal hosting and computing as a service.

\paragraph{On-demand self-service.} 

With \emph{on-demand self-service} consumers can achieve provisioning without any human interaction.
On-demand means dynamic scalability and elasticity of resource allocation,
self-service so that users do not need to manually do these allocations themselves.
Consider an online election system, for most of the year it will have 
low usage demands, but before and under election days it will have to serve
a much larger amount of requests. With \emph{on-demand self-service} the online election system
could automatically be given more resources such as memory, computation power or even
increase the number of instances to handle peak loads.
The previous example has planned (or known) peak intervals, so even though automatic handling
is appealing it could be solved by good planning. 
But sometimes predicting peak loads can be difficult, such as when a product suddenly
becomes more popular than first anticipated.
Twitter is a good example of a service that can have difficulties in estimating 
the amount of user demand and total amount of incoming requests.
For instance in the year $2011$ they achieved a record in \myac{TPS} of
$25,088$ triggered by a Japanese television screening of the movie ``Castle in the Sky''.
Each ``tweet'' essentially becomes at least one request to Twitter services.
On a normal basis the service does not have to cope with this amount of requests, so
this event was a strong and unpredicted fluctuation in day-to-day operations,
and this is the kind of scenarios that cloud computing can help to tackle with
characteristics such as \emph{on-demand self-service}.
With \emph{on-demand self-service} allocation will automatically scale upwards as popularity increases 
and downwards as resources become superfluous.

\paragraph{Broad network access.}

When working against cloud solutions, in form of management, monitoring or other 
interactions it is important that capabilities are available over standard network mechanisms,
supporting familiar protocols such as \myac{HTTP}/HTTPS and \myac{SSH}.
So users can utilize tools and software they already possesses
or will have little difficulty gaining, such as web browsers.
This is what the characteristic \emph{broad network access} is all about,
ensuring familiar mechanisms for communicating with a cloud service.
Most cloud providers also provide web based consoles/interfaces that users can use
to create, delete and manage their resources.

\paragraph{Resource pooling.}

Physical and virtual resources are pooled so they can be 
dynamically assigned and reassigned according to consumer demand.
Users do not need to be troubled with scalability as this is handled automatically.
This is a provider side characteristic which directly influence \emph{on-demand self-service}.
There is also a sense of location independence, users can choose geographical locations
on higher abstracted levels such as country or sate, but not always as detailed or specific as city.
It is important that users can choose at least country as geographical location
for their product deployments for instance to reduce latency between product and customers
based on customer location or data storing rules set by government.

\paragraph{Rapid elasticity.}

Already allocated resources can expand vertically to meet new demands,
so instead of provisioning more instances (horizontal scaling) existing
instances are given more resources such as \myac{RAM} and \myac{CPU}.
Towards the characteristic of \emph{on-demand self-service} allocation
can happen instantly, which means on unexpected peak loads the pressure will be
instantly handled by scaling upwards.
It is important to underline that such features can be financially cost heavy if not limited,
because costs reflect resource allocation.

\paragraph{Measured service.}

Monitoring and control of resource usages.
Can be used for statistics for users, for instance to do analytical research on product popularity
or determine user groups based on geographical data or browser usage.
The providers themselves use this information to handle \emph{on-demand services},
if they notice that an instance has a peak in load or has a noticeable increase 
in requests they can automatically allocate more resources or capabilities 
to leave pressure.
\emph{Measuring} can also help providers with billing, if they for instance
charge by resource load and not only amount of resources allocated.

\subsection{Service models}
\input{figs/cloudlayers}

\emph{Service models} are definitions of different layers in cloud computing.
The layers represent the amount of abstraction developers get from each \emph{service model}.
Higher layers have more abstraction, but can be more limited, while lower levels 
have less abstraction and are more customizable.
Limitations could be in many different forms, such as bound to a specific operating system,
programming language or framework.
There are three main architectural service models in cloud computing\cite{nist:mell11}
as seen as vertical integration levels in \citefig{cloudlayers},
namely \myac{IaaS}, \myac{PaaS} and \myac{SaaS}.
IaaS is on the lowest closest to physical hardware and SaaS on the highest
level close to runnable applications.

\paragraph{IaaS.}

This layer is similar to more standard solutions such as \myac{VPS},
and is therefore the \emph{service model} closest to standard hosting solutions.
Stanoevska-Slabeva~\cite{introduction:wozniak10} emphasizes that
\emph{''infrastructure had been available as a service for quite some time``} and this 
\emph{''has been referred to as utility computing, such as Sun Grid Compute Utility``}.
Which means IaaS can also be compared to grid computing, 
a well known computing model in the academic world.
\epigraph{The capability provided to the consumer is to provision 
  processing, storage, networks, and other fundamental computing resources where the 
  consumer is able to deploy and run arbitrary software, which can include operating 
  systems and applications.
}{\citet{nist:mell11}}
This underline the liberty this \emph{service model} provides to users, but this also means
that developers need to handle software and tools themselves, from operating system and
up to their application. In some cases this is advantageous, for instance when deploying 
native libraries and tools that applications rely on such as tools to convert and edit
images or video files. But in other cases this is not necessary and choosing this \emph{service model}
can be manpower in-effective for companies as developers must focus on meta tasks.
\epigraph{The consumer does not manage or control the underlying cloud 
  infrastructure but has control over operating systems, storage, deployed applications, and 
  possibly limited control of select networking components (\eg, host firewalls).
}{\citet{nist:mell11}}
Users have control over which operating system they want, in some cases users
can only pick from a set of pre-configured operating systems.
It is common for providers to include both Linux and Windows in their selections.
Some providers such as Amazon let users upload their own disk images.
A similarity to \myac{VPS} is that operating systems are not manually installed,
when selecting an operating system this is copied directly into the instance pre-installed
and will therefore be instantly ready for usage.
Examples of providers of IaaS are \myac{AWS} \myac{EC2} and Rackspace CloudServers.

\paragraph{PaaS.}

Cloud computing is built to guide and assist developers through abstractions, and the next
layer in the \emph{service model} is designed to aid developers by detaching them
from configuration of operating system and frameworks.
Developers are limited to capabilities the provider support,
such as programming languages (Java, C\#), environments (\myac{JVM}, .NET, Node.js), 
storage systems (flat files, NoSQL databases, \myac{RDBMS}),
services (load balancers, backup, content delivery)
and tools (plugin for Eclipse, command line tools)~\cite{nist:mell11}.
For example the first versions of \myac{GAE} did only support
an internal key-value based database called BigTable, which is still their main database.
This database is transparently interfaced using their \myac{API}, 
but also support technologies such as \myac{JPA} and \myac{JDO},
users are bound to Java and these frameworks, and even limitations to the frameworks
as they have specific handlers for \myac{RDBMS}.
The disconnection from operating system is the strength of \myac{PaaS} solutions,
on one hand developers are restricted, but they are also freed from
configuration, installments and maintaining deployments.
Some \myac{PaaS} providers support additional convenient capabilities such as
test utilities for deployed applications and translucent scaling.
In the end developers can put all focus on developing applications 
instead of spending time and resources on unrelated tasks.

PaaS providers support deployments through online \myac{API}s, in many cases by providing 
specific tools such as command line interfaces or plugins to \myac{IDE}s like Eclipse.
It is common for the \myac{API} to have client built on technologies related to the technology supported by the PaaS,
for instance Heroku has a Ruby-based client and Nodejitsu has an executable Node.js-module as client.

Examples of PaaS providers are Google with \myac{GAE} and
the company Heroku with their eponymous service.
Amazon also entered the PaaS market with their service named Elastic Beanstalk,
which is an abstraction over \myac{EC2} as IaaS underneath.
Multiple PaaS providers utilize \myac{EC2} as underlying infrastructure, examples of such
providers are Heroku and Nodester, this is a tendency with increasing popularity.

\paragraph{SaaS.}

The highest layer of the \emph{service models} farthest away from physical hardware
and with highest level of abstraction.
\epigraph{The capability provided to the consumer is to use the provider's 
  applications running on a cloud infrastructure.
}{\citet{nist:mell11}}

The core purpose is to provide complete applications as services, in many cases end products.
Google products such as Gmail, Google Apps and  Google Calendar are examples of 
SaaS applications.
What separates SaaS applications from other applications are the underlying cloud infrastructure,
by utilizing the five characteristics of cloud computing SaaS applications achieve 
cloud computing advantages.

It is not imposed that SaaS deployments are web applications, they can also consist of
different technologies such as \myac{REST} \myac{API}s or SOAP services, but in any case it is 
most common to utilize the \myac{HTTP}.
In SaaS applications end users are most likely not the companies renting from providers, 
but instead the companies customers.
The abstraction layer covers most of all aspects around an application,
the only exception could be customizations and settings that end users can do albeit 
this can be application specific. In some cases providers have services that affect
these users as well, such as \emph{Single Sign-on}.

\subsection{Deployment models}

\emph{Deployment models} define where and how applications are deployed in a cloud environment,
such as publicly with a global provider or private in local data centers.
There are four main \emph{deployment models}.

\paragraph{Public cloud.}

In this deployment model infrastructure is open to the public,
so companies can rent services from cloud providers.
Cloud providers own the hardware and rent out IaaS and PaaS solutions to users.
Examples of such providers are Amazon with \myac{AWS} and Google with \myac{GAE}.
The benefit of this model is that companies can save costs as 
they do not need to purchase physical hardware or manpower to build and maintain such hardware.
It also means that a company can scale their infrastructure without having to
physically expand their data center.

\paragraph{Private cloud.}

Similar to classical infrastructures where hardware and
operation is owned and controlled by organizations themselves.
This deployment model has arisen because of security issues regarding storage 
of data in public clouds. With \emph{private cloud} organization can provide 
data security in forms such as geographical location and existing domain specific firewalls,
and help comply requirements set by the government or other offices.
Beside these models defined by \myac{NIST} there is another arising model known as 
\myac{VPC}, which is similar to \emph{public cloud} 
but with some security implications such as sandboxed network.
With this solution companies can deploy cluster application and enhance 
or ensure security within the cluster, for example by disabling remote access
to certain parts of a cluster and routing all data through safe gateways or firewalls.
In \emph{public clouds} it can be possible to reach other instances on a local network,
also between cloud customers.

\paragraph{Community cloud.}

Similar as \emph{private clouds} but run as a coalition between several organizations.
Several organizations share the same aspects of
a private cloud (such as security requirements, policies, and compliance considerations),
and therefore share infrastructure. 
This type of \emph{deployment model} can be found in universities where resources 
can be shared between other universities.

\paragraph{Hybrid cloud.}

One benefit is to distinguish data from logic for purposes such as security issues,
by storing sensitive information in a private cloud while computing with public cloud.
For instance a government can establish by law how and where some types of informations 
must be stored, such as privacy law. 
To sustain such laws a company could store data on their own \emph{private cloud}
while doing computation on a \emph{public cloud}.
In some cases such laws relates only to geographical location of stored data,
making it possible to take advantage of \emph{public clouds} that can guarantee
geographical deployment within a given country.

\section{Model-Driven Engineering}

By combining the domain of cloud computing with the one of modeling 
it is possible to achieve benefits such as improved communication when designing 
a system and better understanding of the system itself.
This statement is emphasized by Booch \etal in the UML:
\epigraph{
  Modeling is a central
  part of all the activities that lead up to the deployment of good
  software. We build models to communicate the desired structure and
  behavior of our system. We build models to visualize and control the
  system's architecture. We build models to better understand the
  system we are building, often exposing opportunities for
  simplification and reuse. We build models to manage risk.
}{\cite{unified:booch05}}
When it comes to cloud computing these definitions are even more important
because of financial aspects since provisioned nodes instantly draw credit.
The definition of ``modeling'' can be assessed from the previous epigraph, but it is 
also important to choose correct models for the task.
Stanoevska-Slabeva emphasizes in one of her studies that grid computing
``\emph{is the starting point and basis for Cloud Computing.}''~\cite{introduction:wozniak10}.
As grid computing bear similarities towards cloud computing in terms of virtualization 
and utility computing
it is possible to use the same \myac{UML} diagrams for IaaS as previously used in grid computing.
The importance of this re-usability of models is based on the origin of grid computing, 
\emph{eScience},
and the popularity of modeling in this research area.
The importance of choosing correct models is emphasized by~\cite{unified:booch05}:
\epigraph{
  \begin{ii}\iitem The choice
  of what models to create has a profound influence on how a problem
  is attacked and how a solution is shaped. \iitem Every model may be
  expressed at different levels of precision. \iitem The best models
  are connected to reality. \iitem No single model is
  sufficient. Every nontrivial system is best approached through a
  small set of nearly independent models.\end{ii}
}{\cite{unified:booch05}}
These definition precepts state that several models (precept \iii{4}) on different levels (precept \iii{2}) 
of precision should be used to model the same system.
From this it is concludable that several models can be used to describe one or several cloud computing perspectives.
Nor are there any restraints to only use \myac{UML} diagrams or even diagrams at all.
As an example \myac{AWS} CloudFormation implements a lexical model of their \emph{cloud services},
while CA AppLogic has a visual and more \myac{UML} component-based diagram of their capabilities.

\paragraph{Model-Driven Architecture.}
\input{figs/mda}

\myac{MDA} is a way of designing software with modeling in mind provided by the \myac{OMG}.
When working with \myac{MDA} it is common to first create a \myac{CIM}, then a \myac{PIM} and
lastly a \myac{PSM} as seen in~\citefig{mda}. There are other models and steps in between these,
but they render the essentials.
Beside the models there are five different steps as explained by Singh~\cite{model-driven:singh09}:
\begin{enumerate}
  \item \emph{Create a \myac{CIM}}.
    This is done to capture requirements and describe the domain.
    To do this the \myac{MDA} developer must familiarize with the business organization
    and the requirements of this domain. This should be done without any specific technology.
    The physical appearance of \myac{CIM} models can be compared to \emph{use case} diagrams in \myac{UML},
    where developers can model actors and actions (use cases) based on a specific domain.
  \item \emph{Develop a \myac{PIM}.}
    The next step aims at using descriptions and requirements from the \myac{CIM}
    with specific technologies. The \myac{OMG} standard for \myac{MDA} use \myac{UML} models,
    while other tools or practices might select different technologies.
    Example of such \emph{Platform Independent Models} can be class diagrams in \myac{UML}
    used to describe a domain on a technical level.
  \item \emph{Convert the \myac{PIM} into \myac{PSM}.}
    The next step is to convert the models into something more concrete
    and specific to a platform. Several \myac{PSM} and be used to represent one \myac{PIM} as seen in \citefig{mda}.
    Examples of such models can be to add language specific details to \myac{PIM} class
    diagram such as types (String, Integer) for variables, access levels (private, public),
    method return types and argument types.
    Kent, Stuart~\cite{modeldriven:kent02} emphasizes the importance 
    of this mapping in one of his studies:
    \epigraph{
      A \myac{PSM} is not a \myac{PIM}, but is also not an implementation. [\ldots]
      In \myac{MDA}, the main mapping is between \myac{PIM}
      and \myac{PSM}, and this is often associated with code generation. 
      However, this is not the only kind of mapping required.
    }{\citet{modeldriven:kent02}}
    From this it is possible to determine that a \myac{PSM} is more specific to a platform then \myac{PIM}, such as 
    programming language or environment.
  \item \emph{Generate code form \myac{PSM}.}
    A \myac{PSM} should be specific enough that code can be generated from the models.
    For instance can class diagrams be generated into entities, and additional
    code for managing the entities can be added as well.
    Some diagrams such as \myac{BPMN} can generate \myac{BPEL} which again can generate executable logic.
  \item \emph{Deploy.}
    The final step is based on deploying the \myac{PSM}, which concludes the five steps from
    loosely descriptions of a domain to a running product.
    Different environmental configurations can be applied in step $4$ to assure deployments
    on different systems, this without changing the \myac{PSM} from step in step $3$.
\end{enumerate}
