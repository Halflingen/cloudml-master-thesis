\mychapter{problem}{Challenges in the cloud}

As cloud computing is growing in popularity it is also growing in complexity.
More and more providers are entering the market and different types of solutions are made.
There are few physical restrictions on how a provider should let their users do provisioning,
and little limitations in technological solutions.  
The result can be a complex and struggling introduction to cloud computing for users,
and provisioning procedure can alternate between providers.

This chapter will outline research on which has been conducted by
physical provisioning of an example application.
First the scenario will be introduced, describing the example application
and different means of provisioning in form of topologies.
Then challenges identified from the research will be presented.

\section{Scenario}

\input{figs/nodes}

To recognize challenges when doing cloud provisioning an example application~\cite{BankManager} was utilized.
The application (from here known as \emph{BankManager}) is a prototypical bank manager system
wich support creating users and bank accounts and moving money between bank accounts and users.
The application is based on a three-tier architecture with 
\begin{ii} 
  \iitem presentation tier with a web-based interface,
  \iitem logic tier with controllers and services and
  \iitem database tier with models and entities.
\end{ii}
It is designed but not limited to support distribution between several nodes.
Some examples of provisioning topologies is illustrated in \citefig{BankManager}, each
example includes a browser to visualize application flow, front-end visualizes executable
logic and back-end represents database.
It is possible to have both front-end and back-end on the same node, as shown in \citefig{singlenode}.
In \citefig{twonodes} front-end is separated from back-end, 
this introduces the flexibility of increasing computation power on the front-end node while spawning more
storage on the back-end. 
For applications performing heavy computations it can be beneficial to distribute the workload between several
front-end nodes as seen in \citefig{threenodes}, the number of front-ends can be linearly increased 
$n$ number of times as shown in \citefig{frontends}.
\emph{BankManager} is not designed to handle several back-ends because of \myac{RDBMS},
this can solved on a database level with master and slaves (\citefig{frontendbackends}).
Bash-scripts were used to prototype full deployments of \emph{BankManager} against 
\myac{AWS}~\cite{aws}
and Rackspace~\cite{rackspace} with a topology of three nodes as shown in \citefig{threenodes}.

\section{challenges}

From this prototype it became clear that there were multiple challenges to address

\paragraph{Complexity.} 

The first challenge encountered was to simply
authenticate and communicate with the cloud. The two providers 
had different approaches, AWS~\cite{aws} had command-line tools built from their Java APIs,
while Rackspace~\cite{rackspace} had no tools beside the API language bindings,
thus the need of operating both command-line tools as well as public APIs.
As this emphasizes the complexity even further it also stresses engineering capabilities
of individuals executing the tasks to a higher technical level.

\paragraph{Multicloud.}

Once able to provision the correct amount of nodes with desired properties
on the first provider it became clear that mirroring the setup to the other provider 
was not as convenient as anticipated.
There were certain aspects of vendor lock-in, so each script was hand-crafted for specific providers.
The lock-in situations can in many cases have financial implications where for example
a finished application is locked to one provider and this provider increases tenant costs.
Or availability decreases and results in decrease of service uptime damaging revenue.

\paragraph{Reproducibility.}

The scripts provisioned nodes based on command-line arguments
and did not persist the designed topology in any way, this made topologies cumbersome to reproduce.

\paragraph{Shareable.}

Since the scripts did not remember a given setup it was impossible 
to share topologies ``as is'' between coworkers.
It is important that topologies can be shared because direct input from individuals
with different areas of competence can increase quality.

\paragraph{Robustness.}

There were several ways the scripts could fail and most errors were ignored.
Transactional behaviors were non-existent.

\paragraph{Run-time dependency.}

The scripts were developed to fulfill a complete deployment,
and to do this it proved important to temporally save run-time specific metadata.
This was crucial data needed to connect front-end nodes with the back-end node.


\section{Why is it important to solve the problems}

\input{tables/analysis}

\todo{
  \begin{itemize}
    \item Cloud domain is state of the art
    \item model driven approach with benefits (no special tooling)
    \item Easier for businesses (especially SMBs) to reach out to Cloud
    \item Easier for larger more time-constraint businesses to try out the cloud
    \item Opening the eyes of big providers for a larger cross-cloud language
  \end{itemize}
}
