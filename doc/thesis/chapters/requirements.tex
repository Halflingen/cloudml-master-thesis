\mychapter{requirements}{Requirements}

In \citechap{challenges} challenges were identified, in this chapter those challenges
will be addressed and tackled through requirements.
The requirements are descriptions of important aspects and needs derived from the previous chapter.
A table overview will display consecutive challenges and requirements. 
This table is angled to the challenges point of view to clarify requirements relation to challenges,
and one requirement can try to solve several challenges.

The requirements are expressed in \citefig{requirements}.
Four of these requirements have dependencies to each other.
These dependencies are shown through lines linking the requirements
together.

\input{figs/requirements}

\req{software-reuse}{Software reuse}
There were several technological difficulties with the scripts from the scenario in 
\citechap{challenges}.
And one requirement that could leverage several of the challenges
originating from these particular issues would be to utilize an existing framework or library.
If possible it would be beneficial to not \emph{``Reinvent the wheel''} and rather use work
that others have done that solve the same problems.
In the chapter \citechap{state-of-the-art} multi-cloud \myac{API}s 
were described, such as \emph{libcloud} and \emph{jclouds}.
The core of this requirement is to find and experiment with different APIs to find one
that suite the needs to solve some of the challenges from \citechap{challenges}.
One of these challenges would be \emph{complexity} where such software utilization
could help to authenticate to providers and leverage understanding of the technology.
Such library could also help with \emph{feedback} in case an exception should occur, on one
side because the error handling would be more thoroughly tested and used,
and another side because the library would be more tightly bounded with \citereq{foundation}.
And for the same reasons such framework could make the whole application more \emph{robust}.

All of the API libraries from \citechap{state-of-the-art} support \emph{multi-cloud} so they can
interact with several providers over a common interface, this would be a mandatory challenge
to overcome by this requirement.
Some research have already been done to indicate what their purpose is, 
how they operate and to some extent how to use them.
The approach here is to select libraries or framework that could match well with a chosen
\citereq{foundation} or help fulfill this requirement.
Then the chosen \myac{API}s must be narrowed down to one single \myac{API} which will be
used in the solution application.

\req{foundation}{Strong technological foundation}
Beside the benefits of \citereq{software-reuse} there could be even additional gain by choosing
a solid technology underneath the library, \eg \emph{programming language},
\emph{application environment}, \emph{common libraries}, \emph{distribution technologies}.
The core of this requirement is to find, test and experiment with technologies that can solve
challenges and even give additional benefits.
Such technologies could be anything from Java for enterprise support to open source repository
sites to support software distribution.
It is also important that such technologies operate flawlessly with libraries or frameworks
found and chosen from the requirement of \citereq{software-reuse}.
The technology chosen should benefit the challenge of \emph{robustness}.
It could also help to solve other challenges such as \emph{metadata dependency} by introducing
functionality through \emph{common libraries} or some built in mechanism.

Solid technologies have to be considered by several aspects, such as
\begin{ii}
  \iitem ease of use,
  \iitem community size,
  \iitem closed/open source,
  \iitem business viability,
  \iitem modernity and 
  \iitem matureness.
\end{ii}
Another important aspect is based on library or framework chosen for the \citereq{software-reuse} requirement,
as the library will directly affect some technologies such as programming language.
Different technologies have to be researched and to some degree physically tried out to identify
which aspects they fulfill.

Types of technologies are undefined but some are mandatory such as 
\begin{ii}
  \iitem programming language (\eg Java, C\#) and 
  \iitem application environment (\eg JDK, .NET).
\end{ii}
Beside this it is also important to state which type of application the solution should be, 
\begin{ii}
  \iitem GUI application,
  \iitem \myac{API} in form of public Web Service or
  \iitem \myac{API} in form of native library.
\end{ii}
The amount of different technologies is overwhelming so looking into all of them would be impossible,
therefore they must be narrowed down based on aspects such as popularity.

\req{mda}{Model-Driven approach}
Models can be reused to multiply a setup without former knowledge of the system.
They can also be used to discuss, edit and design topologies for propagation. 
These are important aspects that can help to leverage the challenge of \emph{complexity}.

Main objective is to create a common model for nodes as a platform-independent 
model~\cite{agile:cuong10} to justify \emph{multi-cloud} differences and 
at the same time base this on a human readable lexical format to address \emph{reproducibility} and
make it \emph{shareable}.

Unlike the other requirements this is a non-physical need, 
and as seen in \citefig{requirements}
there are no dependencies from or to this requirement.
But other requirements such as \citereq{lexical-template} are directly based on this one.

In the implementation there will be four different models:
\begin{enumerate}
  \item The lexical template.
  \item Nodes from the template represented in the implementation.
  \item Nodes converted into \emph{instances} for provisioning.
  \item Instances in form of run-time instances (\emph{models@run.time}).
\end{enumerate}
Of these the first is influenced by the \citereq{lexical-template} requirement and
the last by the \citereq{m@rt} requirement.

\req{lexical-template}{Lexical template}
This requirement is tightly coupled with that of \citereq{mda} but narrowed 
even further to state the importance of model type in regard to the model-driven approach.
When approaching a global audience consisting of both academics groups and commercial
providers it is important to create a solid foundation, 
which also should be concrete and easy to both use and implement.
The best approach would be to support both graphical and lexical models, 
but a graphical annotation would not suffice when promising simplicity and ease in implementation. 
Graphical model could also be much more complex to design, 
while a lexical model can define a concrete model on a lower level.
Since the language will be a simple way to template configuration, 
a well known data markup language would be sufficient for the core syntax, such as 
\myac{JSON} or \myac{XML}.

Textual templates that can be shared through mediums such as E-mail or 
\myac{VCS} such as Subversion or Git.
This is important for end users to be able to maintain templates that defines the stacks they have built, 
for future reuse.

The type of direct model representation of topologies will have great impact 
on the solution application.
As described in \citechap{requirements} this representation should be lexical,
but there are several different styles and languages to achieve this.
Some examples of these languages are 
\begin{ii}
  \iitem \myac{XML},
  \iitem \myac{JSON},
  \iitem YAML,
  \iitem \myac{SDL} or
  \iitem \myac{OGDL}.
\end{ii}
As shown in \citefig{requirements} there is a two-way dependency between 
this requirement and \citereq{foundation} requirement.
This dependency can have impact both ways, but unlike the other dependencies in
\citefig{requirements} there exist bindings all the four precedings in
most languages and systems.
Templates could even be stored as any binary type of serialization, 
but this might not be as sufficient as lexical types, more on this
in \citechap{design}.

\req{m@rt}{Models@run.time}
Models that reflect the provisioning models and updates asynchronously. 
As identified by the scenario in \citechap{challenges} metadata from provisioning is crucial to perform
a proper deployment in steps after the provisioning is complete.
One way to solve this issue is by utilizing \myac{M@RT}, which is the most obvious choice in a
model-driven approach.
Models will apply to several parts of the application, such as for topology designing and for the actual propagation.
Models are often used to clarify understanding of a system,
a run-time model is similar to such model, but focuses on a system in operating state.

The models@run.time approach~\cite{DBLP:journals/dagstuhl-reports/AssmannBCF11}
is meant to support any deployment system which should be run sequentially after a complete provisioning.
For such deployment to be successful metadata from the provisioning could be needed,
so the core idea is to fetch this kind of data directly from models@run.time.

The approach for this requirement is to find sufficient solutions for such models,
and at the same time keep in mind the dependency towards \citereq{foundation}.
There are several different approaches that could be made when implementing 
these models, such as using
\begin{ii}
  \iitem observer pattern,
  \iitem command pattern,
  \iitem actor model or
  \iitem publish-subscribe pattern.
\end{ii}
It is also possible to combine one or several of these approaches.
What needs to be done here is to identify which approaches that are most sufficient 
in regards to 
\begin{ii} 
  \iitem finding an approach that solved the requirement,
  \iitem sustain constraints in regard of dependencies as seen in \citefig{requirements}, and
  \iitem identify approaches that can be combined and what benefits this would give.
\end{ii} 

\req{multi-cloud}{Multi-cloud}
One of the biggest problems with the cloud today is the vast amount of different providers. 
There are usually few reasons for large commercial delegates to have support for contestants. 
Some smaller businesses could on the other hand benefit greatly of a standard and union 
between providers.
The effort needed to construct a reliable, stable and scaling computer park or data center will 
withhold commitment to affiliations. 
Cloud Computing users are concerned with the ability to easily swap between different providers, 
this because of security, 
independence and flexibility. 
CloudML and its engine need to apply to several providers with different set of systems, 
features, \myac{API}s, payment methods and services. 
This requirement anticipate support for at least two different providers such as \myac{AWS} and Rackspace.

\section{Comparison}
\input{tables/requirements}

The requirements defined in this chapter are designed to tackle one or more of the challenges
described in \citechap{challenges}.
All of the challenges are associated with requirements, as seen in \citetable{requirements}.
Three of the challenges are tackled by more than one requirement, and three other requirements
tackle more than one challenge.
\eg \citereq{software-reuse} tackle four different challenges including \emph{complexity},
while the challenge \emph{complexity} is tackled by both 
\citereq{software-reuse} and \citereq{mda}.

\section{Requirement dependencies}

Some of the requirements have dependencies on each other, for instance \citereq{software-reuse} is about finding
and utilizing an existing library or framework, but this will also directly affect or be affected by
programming language or application environment chosen in \citereq{foundation} requirement.
There are three requirements, 
\begin{ii}
  \iitem \citereq{m@rt},
  \iitem \citereq{software-reuse} and
  \iitem \citereq{lexical-template},
    where all have a two-way dependency to the 
  \iitem \citereq{foundation} requirement,
\end{ii}
as illustrated in \citefig{requirements}.
These dependency links will affect the end result of all the four previous mentioned requirements.
For example a library chosen in precept \iii{2} would affect precept \iii{4}, which again would affect
how precept \iii{1} will be solved. 
It could also affect precept \iii{3} as different textual solutions can function better in
different environments.
Since \citereq{foundation} is a central dependency (\citefig{requirements})
this requirements is weighted more than the others.

