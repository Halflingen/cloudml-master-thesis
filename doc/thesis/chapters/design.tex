\mychapter{design}{Analysis and design - CloudML}
\input{figs/architecture}
\input{figs/scenario1}
\input{figs/scenario2}
\input{figs/sequencediagram}

\section{Meta model.}

The meta model for CloudML is visualized in~\citefig{architecture}. 
\texttt{CloudMLEngine} is the main entry point, it has the method \texttt{build}
which is used to initialize provisioning.
\texttt{Property} have four children but is designed to be extendable in case
new types of properties should be included. The same design principle
is applied to \texttt{RuntimeProp}.
\texttt{UserLibrary} visualizes that \texttt{Account} and \texttt{Template} are 
physical parts maintainable by the user.

\paragraph{Scenario introduction.}
CloudML is introduced by using two scenarios where ``Alice'' is provisioning the 
\emph{BankManager} from \citechap{challenges} to AWS \emph{Elastic Compute Cloud}~(EC2)
using the topology shown in~\citefig{singlenode} and~\citefig{threenodes}.
It is compulsory that she possesses an AWS account in advance of the scenario.
She will retrieve security credentials for account 
and associate them with \texttt{Password} in \citefig{architecture}.
\texttt{Credential} is used to authenticate her to supported providers through \texttt{Connector}.
The characteristics Alice choose for her \texttt{Nodes} and \texttt{Properties} are fitted
for the chosen topology.
All \texttt{Properties} are optional and thus Alice does not have to define them all.

\paragraph{Scenario with one single node.}
The first scenario Alice want to establish is a single node based one~(\citefig{singlenode}).
Since this single node will handle both computation and storage Alice decides to 
increase capabilities of both processing (number of \texttt{Cores}) and 
\texttt{Disk} size on the \texttt{Node}.

\paragraph{Scenario with three nodes.}
The second scenario is based on~\citefig{threenodes} with two more nodes than in the first scenario.
Alice models the appropriate \texttt{Template} consisting
of three \texttt{Nodes}.
by increasing amount of \texttt{Cores}, and increased \texttt{Disk} for back-end \texttt{Node}.

\paragraph{Provisioning.}
With these models Alice can initialize provisioning by calling 
\texttt{build} on \texttt{CloudMLEngine},
and this will start the asynchronous job of configuring and creating \texttt{Nodes}.
When connecting front-end instances of \emph{BankManager} to back-end instances Alice must 
be aware of the back-ends \texttt{PrivateIP} address, which she will retrieve from CloudML
during provisioning according to \emph{models@run.time}~(M@RT) approach.
\texttt{RuntimeInstance} is specifically designed to complement \texttt{Node} with \texttt{RuntimeProperties},
as \texttt{Properties} from \texttt{Node} still contain valid data.
When all \texttt{Nodes} are provisioned successfully and sufficient metadata are gathered
Alice can start the deployment, CloudML has then completed its scoped task of provisioning.
Alice could later decide to use another provider, either as replacement or complement to her current setup,
because of availability, financial benefits  or support.
To do this she must change the provider name in \texttt{Account} and call \texttt{build} on \texttt{CloudMLEngine} again,
this will result in an identical topological setup on a supported provider.

\paragraph{And we saw?}

\section{Actors model}
Provisioning nodes is by its nature an asynchronous action that can take minutes to execute,
therefore CloudML relied on the actors model~\cite{actors:haller07}.
With this asynchronous solution CloudML got concurrent communication with nodes under provisioning.
The model is extended by adding a callback-based pattern allowing each node to provide 
information on property and status changes.
Developers exploring the implementation can then choose to ``listen'' for updating events from each node,
and do other jobs / idle while the nodes are provisioned with the actors model.
The terms are divided for a node before and under provisioning, the essential is to introduce 
\emph{M@RT} to achieve a logical separation.
When a node is being propagated it changes type to \texttt{RuntimeInstance}, 
which can have a different \emph{states} such as \emph{Configuring}, \emph{Building}, \emph{Starting} and \emph{Started}.
When a \texttt{RuntimeInstance} reaches \emph{Starting} state the provider has guaranteed its existence, including
the most necessary metadata, when all nodes reaches this state the task of provisioning is concluded.
