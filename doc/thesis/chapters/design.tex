\mychapter{design}{Analysis and design - CloudML}
\input{figs/architecture}

\todo{
  \begin{itemize}
    \item Copy chap 3 from CloudMDE
    \item Weaknesses
  \end{itemize}
}

The meta model for CloudML is described in~\citefig{architecture}. 
CloudML is introduced by using a scenario where ``Alice'' is provisioning the 
\emph{BankManager} from \citechap{problem} to AWS \emph{Elastic Compute Cloud}~(EC2)
using the topology shown in~\citefig{threenodes}.
It is compulsory that she possesses an AWS account in advance of the scenario.
She will retrieve security credentials for account 
and associate them with \texttt{Password} in \citefig{architecture}.
\texttt{Credential} is used to authenticate her to supported providers through \texttt{Connector}.
The next step for Alice is to model the appropriate \texttt{Template} consisting
of three \texttt{Nodes}.
The characteristics Alice choose for \texttt{Node} \texttt{Properties} are fitted
for the chosen topology with more computational power for front-end \texttt{Nodes}
by increasing amount of \texttt{Cores}, and increased \texttt{Disk} for back-end \texttt{Node}.
All \texttt{Properties} are optional and thus Alice does not have to define them all.
With this model Alice can initialize provisioning by calling \texttt{build} on \texttt{CloudMLEngine},
and this will start the asynchronous job of configuring and creating \texttt{Nodes}.
When connecting front-end instances of \emph{BankManager} to back-end instances Alice must 
be aware of the back-ends \texttt{PrivateIP} address, which she will retrieve from CloudML
during provisioning according to \emph{models@run.time}~(M@RT) approach.
\texttt{RuntimeInstance} is specifically designed to complement \texttt{Node} with \texttt{RuntimeProperties},
as \texttt{Properties} from \texttt{Node} still contain valid data.
When all \texttt{Nodes} are provisioned successfully and sufficient metadata are gathered
Alice can start the deployment, CloudML has then completed its scoped task of provisioning.
Alice could later decide to use another provider, either as replacement or complement to her current setup,
because of availability, financial benefits  or support.
To do this she must change the provider name in \texttt{Account} and call \texttt{build} on \texttt{CloudMLEngine} again,
this will result in an identical topological setup on a supported provider.

Provisioning nodes is by its nature an asynchronous action that can take minutes to execute,
therefore CloudML relied on the actors model~\cite{actors:haller07} using Scala actors.
With this asynchronous solution CloudML got concurrent communication with nodes under provisioning.
The model is extended by adding a callback-based pattern allowing each node to provide 
information on property and status changes.
Developers exploring the implementation can then choose to ``listen'' for updating events from each node,
and do other jobs / idle while the nodes are provisioned with the actors model.
The terms are divided for a node before and under provisioning, the essential is to introduce 
\emph{M@RT} to achieve a logical separation.
When a node is being propagated it changes type to \texttt{RuntimeInstance}, 
which can have a different \emph{state} such as \emph{Configuring}, \emph{Building}, \emph{Starting} and \emph{Started}.
When a \texttt{RuntimeInstance} reaches \emph{Starting} state the provider has guaranteed its existence, including
the most necessary metadata, when all nodes reaches this state the task of provisioning is concluded.

Full deployment is planed for next version of CloudML.
